<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>粒子心形动画</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script>
        // 1. 创建场景、相机、渲染器
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 2. 创建粒子材质（带发光、透明效果）
        const particleMaterial = new THREE.PointsMaterial({
            color: 0x87CEFA, // 粒子颜色（浅蓝）
            size: 0.1,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending // 叠加混合，实现发光感
        });

        // 3. 生成粒子几何体（心形曲线）
        const particles = [];
        const originalParticles = []; // 保存原始粒子位置，用于后续动画
        const geometry = new THREE.BufferGeometry();
        const heartCurve = (t) => {
            // 心形参数方程
            const x = 16 * Math.sin(t) ** 3;
            const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
            return new THREE.Vector3(x / 10, y / 10, 0); // 缩放并定位
        };

        // 生成大量粒子，围绕心形分布
        for (let i = 0; i < 5000; i++) {
            const t = Math.random() * Math.PI * 2;
            const pos = heartCurve(t);
            // 给粒子添加随机偏移和大小，增强层次感
            pos.x += (Math.random() - 0.5) * 2;
            pos.y += (Math.random() - 0.5) * 2;
            pos.z += (Math.random() - 0.5) * 2;
            particles.push(pos.x, pos.y, pos.z);
            originalParticles.push(pos.x, pos.y, pos.z); // 保存原始位置
        }
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(particles, 3));

        // 4. 创建粒子系统
        const particleSystem = new THREE.Points(geometry, particleMaterial);
        scene.add(particleSystem);

        // 5. 设置相机位置
        camera.position.z = 5;

        // 创建冬天文字弹窗函数
        const createWinterPopup = () => {
            const popup = document.createElement('div');
            popup.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background-color: rgba(70, 130, 180, 0.9);
                color: white;
                padding: 20px 40px;
                border-radius: 10px;
                font-size: 36px;
                font-weight: bold;
                text-align: center;
                z-index: 1000;
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
                animation: fadeIn 1s ease-in-out;
            `;
            popup.textContent = '相见时难别亦难';
            document.body.appendChild(popup);
        };

        // 添加弹窗动画样式
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            }
        `;
        document.head.appendChild(style);

        // 定义动画状态
        const ANIMATION_STATES = {
            SCALING: 'scaling',
            SPREADING: 'spreading',
            COMPLETED: 'completed'
        };
        
        let currentState = ANIMATION_STATES.SCALING;
        let scaleCount = 0;
        let scaleDirection = 1; // 1表示放大，-1表示缩小
        let animationStartTime = performance.now();
        let spreadStartTime = 0;
        let popupCreated = false;
        
        // 6. 动画循环
        function animate() {
            requestAnimationFrame(animate);
            const currentTime = performance.now();
            const elapsedTime = (currentTime - animationStartTime) * 0.001;
            
            const positions = geometry.attributes.position.array;
            
            switch(currentState) {
                case ANIMATION_STATES.SCALING:
                    // 缩放动画，计算当前缩放因子
                    const scaleProgress = elapsedTime % 4; // 每个缩放周期4秒（变慢）
                    let scaleFactor = 1;
                    
                    if (scaleProgress < 2) {
                        // 放大阶段（2秒）
                        scaleFactor = 1 + 0.3 * (scaleProgress / 2); // 缩小缩放范围使变化更平滑
                        if (scaleDirection === -1) scaleDirection = 1;
                    } else {
                        // 缩小阶段（2秒）
                        scaleFactor = 1.3 - 0.3 * ((scaleProgress - 2) / 2);
                        if (scaleDirection === 1) {
                            scaleDirection = -1;
                            scaleCount++;
                            
                            // 检查是否完成了三次缩放
                            if (scaleCount >= 3) {
                                currentState = ANIMATION_STATES.SPREADING;
                                spreadStartTime = currentTime;
                                console.log('开始散开');
                            }
                        }
                    }
                    
                    particleSystem.scale.set(scaleFactor, scaleFactor, scaleFactor);
                    break;
                    
                case ANIMATION_STATES.SPREADING:
                    // 粒子满屏散开动画
                    const spreadElapsed = (currentTime - spreadStartTime) * 0.001;
                    const spreadProgress = Math.min(spreadElapsed / 3, 1); // 5秒内完成散开（变慢）
                    
                    // 计算屏幕边界对应的3D空间范围
                    const screenWidth = window.innerWidth;
                    const screenHeight = window.innerHeight;
                    const aspectRatio = screenWidth / screenHeight;
                    const distance = camera.position.z;
                    const maxX = aspectRatio * distance * Math.tan(Math.PI / 6); // 基于FOV计算
                    const maxY = distance * Math.tan(Math.PI / 6);
                    
                    for (let i = 0; i < positions.length; i += 3) {
                        // 生成随机目标位置，覆盖整个屏幕
                        const targetX = (Math.random() - 0.5) * maxX * 2;
                        const targetY = (Math.random() - 0.5) * maxY * 2;
                        const targetZ = (Math.random() - 0.5) * 10;
                        
                        // 使用更平滑的缓动函数
                        const easeProgress = 1 - Math.pow(1 - spreadProgress, 3); // 三次缓动
                        positions[i] = originalParticles[i] + (targetX - originalParticles[i]) * easeProgress;
                        positions[i+1] = originalParticles[i+1] + (targetY - originalParticles[i+1]) * easeProgress;
                        positions[i+2] = originalParticles[i+2] + (targetZ - originalParticles[i+2]) * easeProgress;
                    }
                    
                    geometry.attributes.position.needsUpdate = true;
                    
                    // 散开完成后显示弹窗
                    if (spreadProgress >= 0.8 && !popupCreated) {
                        createWinterPopup();
                        popupCreated = true;
                    }
                    
                    // 散开完成
                    if (spreadProgress >= 1) {
                        currentState = ANIMATION_STATES.COMPLETED;
                        console.log('动画完成');
                    }
                    break;
                    
                case ANIMATION_STATES.COMPLETED:
                    // 动画完成，保持满屏散开的粒子
                    const time = currentTime * 0.001;
                    for (let i = 0; i < positions.length; i += 3) {
                        // 轻微的浮动效果
                        positions[i] += Math.sin(time + i * 0.01) * 0.01;
                        positions[i+1] += Math.cos(time + i * 0.01) * 0.01;
                    }
                    geometry.attributes.position.needsUpdate = true;
                    break;
            }
            
            renderer.render(scene, camera);
        }
        
        animate();

        // 窗口自适应
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>